---
description: æœ¬æŒ‡å—ç”¨äºåœ¨ Logseq AI æœç´¢æ’ä»¶ä¸­å®ç°ç®€å•çš„æœ¬åœ°å‘é‡å­˜å‚¨ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯å®ç°åŸºäºæœ¬åœ° embedding çš„ã€ä»¥ logseqç¬”è®°è½¯ä»¶ä¸­çš„æœ€å°å•ä½ `block` ä¸ºå•ä½çš„å‘é‡æœç´¢åŠŸèƒ½ã€‚  æˆ‘ä»¬é‡‡ç”¨æœ€ç®€å•çš„æ–¹æ¡ˆï¼š**JSON æ–‡ä»¶å­˜å‚¨ + çº¯ JavaScript å‘é‡æœç´¢**ï¼Œè¿™ç§æ–¹æ¡ˆç®€å•ã€å¯é ã€æ— éœ€å¤æ‚ä¾èµ–ã€‚
alwaysApply: false
---
# ç®€å•å‘é‡å­˜å‚¨ä½¿ç”¨æŒ‡å—

æœ¬æŒ‡å—ç”¨äºåœ¨ Logseq AI æœç´¢æ’ä»¶ä¸­å®ç°ç®€å•çš„æœ¬åœ°å‘é‡å­˜å‚¨ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯å®ç°åŸºäºæœ¬åœ° embedding çš„ã€ä»¥ logseqç¬”è®°è½¯ä»¶ä¸­çš„æœ€å°å•ä½ `block` ä¸ºå•ä½çš„å‘é‡æœç´¢åŠŸèƒ½ã€‚

æˆ‘ä»¬é‡‡ç”¨æœ€ç®€å•çš„æ–¹æ¡ˆï¼š**JSON æ–‡ä»¶å­˜å‚¨ + çº¯ JavaScript å‘é‡æœç´¢**ï¼Œè¿™ç§æ–¹æ¡ˆç®€å•ã€å¯é ã€æ— éœ€å¤æ‚ä¾èµ–ã€‚

## æ ¸å¿ƒä¾èµ–

ä¸ºäº†å®ç°æ­¤åŠŸèƒ½ï¼Œæˆ‘ä»¬åªéœ€è¦ä»¥ä¸‹æ ¸å¿ƒåº“ï¼š

-   `@xenova/transformers`: ç”¨äºåœ¨æœ¬åœ°ç”Ÿæˆæ–‡æœ¬ embedding çš„åº“ï¼ˆå¯é€‰ï¼Œä¹Ÿå¯ä½¿ç”¨ Ollama æˆ–äº‘ç«¯ APIï¼‰ã€‚

## æ ¸å¿ƒå®ç°æ­¥éª¤

### 1. æ•°æ®ç»“æ„è®¾è®¡

å‘é‡æ•°æ®ä»¥ JSON æ ¼å¼å­˜å‚¨ï¼Œæ¯ä¸ªæ¡ç›®åŒ…å« block ä¿¡æ¯å’Œå¯¹åº”çš„å‘é‡ï¼š

```typescript
interface VectorData {
  blockUUID: string;
  pageName: string;
  blockContent: string;
  vector: number[];  // å‘é‡æ•°ç»„
  lastUpdated: number; // æ—¶é—´æˆ³
}

// æ•´ä¸ªå‘é‡æ•°æ®åº“å°±æ˜¯ä¸€ä¸ªæ•°ç»„
type VectorDatabase = VectorData[];
```

### 2. å­˜å‚¨å’ŒåŠ è½½å‡½æ•°

ä½¿ç”¨ Logseq çš„æŒä¹…åŒ–å­˜å‚¨ API æ¥ä¿å­˜å’Œè¯»å–å‘é‡æ•°æ®ï¼š

```typescript
const VECTOR_STORAGE_KEY = 'ai-search-vector-data';

// ä¿å­˜å‘é‡æ•°æ®
async function saveVectorData(vectorData: VectorDatabase): Promise<void> {
  try {
    await logseq.Assets.makeSandboxStorage();
    const jsonString = JSON.stringify(vectorData);
    await logseq.Assets.writeFile(VECTOR_STORAGE_KEY + '.json', jsonString);
    console.log(`ä¿å­˜äº† ${vectorData.length} æ¡å‘é‡æ•°æ®`);
  } catch (error) {
    console.error("ä¿å­˜å‘é‡æ•°æ®å¤±è´¥:", error);
    throw error;
  }
}

// åŠ è½½å‘é‡æ•°æ®
async function loadVectorData(): Promise<VectorDatabase> {
  try {
    await logseq.Assets.makeSandboxStorage();
    const exists = await logseq.Assets.existsFile(VECTOR_STORAGE_KEY + '.json');
    if (!exists) {
      console.log("å‘é‡æ•°æ®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›ç©ºæ•°ç»„");
      return [];
    }
    
    const jsonString = await logseq.Assets.readFile(VECTOR_STORAGE_KEY + '.json');
    const vectorData: VectorDatabase = JSON.parse(jsonString);
    console.log(`åŠ è½½äº† ${vectorData.length} æ¡å‘é‡æ•°æ®`);
    return vectorData;
  } catch (error) {
    console.error("åŠ è½½å‘é‡æ•°æ®å¤±è´¥:", error);
    return [];
  }
}
```

### 3. ç”Ÿæˆ Embedding

æ”¯æŒå¤šç§ embedding ç”Ÿæˆæ–¹å¼ï¼š

```typescript
// Ollama API è°ƒç”¨
async function generateOllamaEmbedding(text: string): Promise<number[]> {
  const ollamaHost = String(logseq.settings?.ollamaHost || "http://localhost:11434");
  const modelName = String(logseq.settings?.ollamaEmbeddingModel || "nomic-embed-text");
  
  try {
    const response = await fetch(`${ollamaHost}/api/embeddings`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: modelName,
        prompt: text
      })
    });

    if (!response.ok) {
      throw new Error(`Ollama API error: ${response.status}`);
    }

    const data = await response.json();
    return data.embedding;
  } catch (error) {
    console.error("Ollama embedding failed:", error);
    throw error;
  }
}

// äº‘ç«¯APIè°ƒç”¨
async function generateCloudEmbedding(text: string): Promise<number[]> {
  const apiUrl = String(logseq.settings?.cloudEmbeddingApiUrl || "https://api.siliconflow.cn/v1/embeddings");
  const apiKey = String(logseq.settings?.cloudEmbeddingApiKey || "");
  const modelName = String(logseq.settings?.cloudEmbeddingModel || "BAAI/bge-m3");

  if (!apiKey) {
    throw new Error("äº‘ç«¯APIå¯†é’¥æœªè®¾ç½®");
  }

  try {
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: modelName,
        input: text
      })
    });

    if (!response.ok) {
      throw new Error(`Cloud API error: ${response.status}`);
    }

    const data = await response.json();
    return data.data[0].embedding;
  } catch (error) {
    console.error("Cloud embedding failed:", error);
    throw error;
  }
}

// ç»Ÿä¸€çš„embeddingç”Ÿæˆå‡½æ•°
async function generateEmbedding(text: string): Promise<number[]> {
  const serviceType = getEmbeddingServiceType();
  
  if (serviceType === 'ollama') {
    return await generateOllamaEmbedding(text);
  } else {
    return await generateCloudEmbedding(text);
  }
}

function getEmbeddingServiceType(): 'ollama' | 'cloud' {
  const selected = String(logseq.settings?.embeddingModel || "Ollamaæœ¬åœ°æ¨¡å‹ / Ollama Local Model");
  return selected.includes("Ollama") ? 'ollama' : 'cloud';
}
```

### 4. æ„å»ºå‘é‡ç´¢å¼•

éå†æ‰€æœ‰ blocksï¼Œç”Ÿæˆå‘é‡å¹¶ä¿å­˜ï¼š

```typescript
async function indexAllPages(): Promise<void> {
  try {
    logseq.UI.showMsg("å¼€å§‹å»ºç«‹å‘é‡ç´¢å¼•...", "success");
    console.log("Starting to build vector index...");

    const allBlocks = await getAllBlocksWithPage();
    if (!allBlocks || allBlocks.length === 0) {
      logseq.UI.showMsg("æ²¡æœ‰éœ€è¦ç´¢å¼•çš„å†…å®¹ã€‚", "warning");
      return;
    }

    // æµ‹è¯•æ¨¡å¼ï¼šåªç´¢å¼•éƒ¨åˆ†blocks
    const testLimit = Number(logseq.settings?.testModeBlockLimit) || 0;
    const blocksToIndex = testLimit > 0 ? allBlocks.slice(0, testLimit) : allBlocks;
    
    console.log(`Found ${allBlocks.length} blocks total, indexing ${blocksToIndex.length} blocks.`);
    if (testLimit > 0) {
      logseq.UI.showMsg(`ğŸ§ª æµ‹è¯•æ¨¡å¼ï¼šåªç´¢å¼•å‰ ${blocksToIndex.length} ä¸ªblocks`, "info", { timeout: 3000 });
    }
    
    const vectorData: VectorDatabase = [];
    let indexedCount = 0;
    const currentTime = Date.now();
    
    for (const block of blocksToIndex) {
      try {
        const vector = await generateEmbedding(block.content);
        vectorData.push({
          blockUUID: block.uuid,
          pageName: block.pageName,
          blockContent: block.content,
          vector: vector,
          lastUpdated: currentTime
        });
        
        indexedCount++;
        
        // æ˜¾ç¤ºè¿›åº¦
        const progress = Math.round((indexedCount / blocksToIndex.length) * 100);
        if (indexedCount % 10 === 0 || indexedCount === blocksToIndex.length) {
          logseq.UI.showMsg(`ç´¢å¼•å»ºç«‹ä¸­... ${progress}% (${indexedCount}/${blocksToIndex.length})`);
          console.log(`Indexed ${indexedCount}/${blocksToIndex.length} blocks (${progress}%)`);
        }
      } catch (error) {
        console.error(`Failed to generate embedding for block ${block.uuid}:`, error);
        // ç»§ç»­å¤„ç†å…¶ä»–blocks
      }
    }

    // ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨
    await saveVectorData(vectorData);
    
    logseq.UI.showMsg(`âœ… ç´¢å¼•å»ºç«‹å®Œæˆï¼å…± ${indexedCount} æ¡å†…å®¹ã€‚`, "success", { timeout: 5000 });

  } catch (error) {
    console.error("Failed to index all pages:", error);
    logseq.UI.showMsg("ç´¢å¼•å»ºç«‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ã€‚", "error");
  }
}
```

### 5. å‘é‡æœç´¢å‡½æ•°

ä½¿ç”¨ä½™å¼¦ç›¸ä¼¼åº¦è¿›è¡Œå‘é‡æœç´¢ï¼š

```typescript
// è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
function cosineSimilarity(vecA: number[], vecB: number[]): number {
  if (vecA.length !== vecB.length) {
    throw new Error('å‘é‡ç»´åº¦ä¸åŒ¹é…');
  }
  
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  
  for (let i = 0; i < vecA.length; i++) {
    dotProduct += vecA[i] * vecB[i];
    normA += vecA[i] * vecA[i];
    normB += vecB[i] * vecB[i];
  }
  
  if (normA === 0 || normB === 0) {
    return 0;
  }
  
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}

// å‘é‡æœç´¢
async function searchBlocks(queryText: string, limit: number = 10) {
  try {
    console.log(`Searching for: "${queryText}"`);
    
    // ç”ŸæˆæŸ¥è¯¢å‘é‡
    const queryVector = await generateEmbedding(queryText);
    
    // åŠ è½½æ‰€æœ‰å‘é‡æ•°æ®
    const vectorData = await loadVectorData();
    
    if (vectorData.length === 0) {
      logseq.UI.showMsg("å‘é‡æ•°æ®ä¸ºç©ºï¼Œè¯·å…ˆå»ºç«‹ç´¢å¼•", "warning");
      return [];
    }
    
    // è®¡ç®—ç›¸ä¼¼åº¦å¹¶æ’åº
    const results = vectorData.map(item => ({
      blockUUID: item.blockUUID,
      pageName: item.pageName,
      blockContent: item.blockContent,
      score: cosineSimilarity(queryVector, item.vector)
    }))
    .sort((a, b) => b.score - a.score)  // æŒ‰ç›¸ä¼¼åº¦é™åºæ’åˆ—
    .slice(0, limit);  // å–å‰ limit ä¸ªç»“æœ

    console.log("Search results:", results);
    return results;

  } catch (error) {
    console.error("Search failed:", error);
    logseq.UI.showMsg("æœç´¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ã€‚", "error");
    return [];
  }
}
```

### 6. è¾…åŠ©å‡½æ•°

```typescript
interface BlockWithPage {
  uuid: string;
  content: string;
  pageName: string;
}

// è·å–æ‰€æœ‰é¡µé¢ä¸­çš„ Block
async function getAllBlocksWithPage(): Promise<BlockWithPage[]> {
  try {
    const allPages = await logseq.Editor.getAllPages();
    if (!allPages) {
      return [];
    }

    let allBlocks: BlockWithPage[] = [];

    for (const page of allPages) {
      const pageBlocks = await logseq.Editor.getPageBlocksTree(page.name);
      if (pageBlocks) {
        const flattenedBlocks = flattenBlocks(pageBlocks).map(block => ({
          uuid: block.uuid,
          content: block.content,
          pageName: page.name
        }));
        allBlocks = allBlocks.concat(flattenedBlocks);
      }
    }
    
    // è¿‡æ»¤æ‰å†…å®¹ä¸ºç©ºçš„ block
    return allBlocks.filter(block => block.content && block.content.trim() !== '');

  } catch (error) {
    console.error("Error getting all blocks:", error);
    return [];
  }
}

function flattenBlocks(blocks: BlockEntity[]): BlockEntity[] {
  let flattened: BlockEntity[] = [];
  for (const block of blocks) {
    flattened.push(block);
    if (block.children && block.children.length > 0) {
      flattened = flattened.concat(flattenBlocks(block.children as BlockEntity[]));
    }
  }
  return flattened;
}

// è·å–ç»Ÿè®¡ä¿¡æ¯
async function getVectorStoreStats() {
  try {
    const vectorData = await loadVectorData();
    const count = vectorData.length;
    const dim = vectorData.length > 0 ? vectorData[0].vector.length : 0;
    return { count, dim };
  } catch (error) {
    console.error("Failed to get vector store stats:", error);
    return { count: 0, dim: 0 };
  }
}
```

## ä¼˜åŠ¿

è¿™ä¸ªç®€å•æ–¹æ¡ˆå…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

1. **ç®€å•å¯é **ï¼šæ— éœ€å¤æ‚çš„æ•°æ®åº“ä¾èµ–ï¼Œåªä½¿ç”¨ JSON æ–‡ä»¶å­˜å‚¨
2. **å®Œå…¨æœ¬åœ°**ï¼šæ•°æ®å­˜å‚¨åœ¨ Logseq æ’ä»¶çš„æ²™ç®±å­˜å‚¨ä¸­ï¼Œå®Œå…¨ç§æœ‰
3. **æ˜“äºè°ƒè¯•**ï¼šå¯ä»¥ç›´æ¥æŸ¥çœ‹å’Œç¼–è¾‘ JSON æ–‡ä»¶
4. **å¿«é€Ÿå¯åŠ¨**ï¼šæ— éœ€åˆå§‹åŒ–å¤æ‚çš„æ•°æ®åº“
5. **å†…å­˜å‹å¥½**ï¼šåªåœ¨éœ€è¦æ—¶åŠ è½½æ•°æ®åˆ°å†…å­˜
6. **è·¨å¹³å°å…¼å®¹**ï¼šåœ¨ä»»ä½•æ”¯æŒ Logseq çš„å¹³å°ä¸Šéƒ½èƒ½å·¥ä½œ

## æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½è€ƒè™‘**ï¼šå¯¹äºå¤§é‡æ•°æ®ï¼ˆ>10ä¸‡ä¸ªblocksï¼‰ï¼Œæœç´¢å¯èƒ½ä¼šæ¯”è¾ƒæ…¢
2. **å†…å­˜ä½¿ç”¨**ï¼šæ‰€æœ‰å‘é‡æ•°æ®ä¼šåŠ è½½åˆ°å†…å­˜ä¸­è¿›è¡Œæœç´¢
3. **å¤‡ä»½**ï¼šJSON æ–‡ä»¶å¯ä»¥ç›´æ¥å¤åˆ¶å¤‡ä»½ï¼Œä¾¿äºæ•°æ®è¿ç§»
4. **å¢é‡æ›´æ–°**ï¼šç›®å‰æ˜¯å…¨é‡é‡å»ºç´¢å¼•ï¼Œåç»­å¯ä»¥ä¼˜åŒ–ä¸ºå¢é‡æ›´æ–°

## å‚è€ƒèµ„æº

- [Logseq Plugin API](https://plugins-doc.logseq.com/) - äº†è§£ Logseq æ’ä»¶å¼€å‘
- [Logseq Assets API](https://plugins-doc.logseq.com/#/hi_logseq.assets) - äº†è§£æ–‡ä»¶å­˜å‚¨ API

- [VSS æ‰©å±•æ–‡æ¡£](https://github.com/duckdb/duckdb_vss) - äº†è§£å‘é‡æœç´¢æ‰©å±•çš„ä½¿ç”¨æ–¹æ³•
- [DuckDB SQL å‚è€ƒ](https://duckdb.org/docs/sql/introduction) - äº†è§£DuckDBçš„SQLè¯­æ³•
- [DuckDB æ•°ç»„ç±»å‹](https://duckdb.org/docs/sql/data_types/array) - äº†è§£å¦‚ä½•ä½¿ç”¨æ•°ç»„å­˜å‚¨å‘é‡
- [HNSW ç´¢å¼•](https://github.com/duckdb/duckdb_vss#hnsw-index) - äº†è§£HNSWç´¢å¼•çš„åˆ›å»ºå’Œä½¿ç”¨
# ç®€å•å‘é‡å­˜å‚¨ä½¿ç”¨æŒ‡å—

æœ¬æŒ‡å—ç”¨äºåœ¨ Logseq AI æœç´¢æ’ä»¶ä¸­å®ç°ç®€å•çš„æœ¬åœ°å‘é‡å­˜å‚¨ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯å®ç°åŸºäºæœ¬åœ° embedding çš„ã€ä»¥ logseqç¬”è®°è½¯ä»¶ä¸­çš„æœ€å°å•ä½ `block` ä¸ºå•ä½çš„å‘é‡æœç´¢åŠŸèƒ½ã€‚

æˆ‘ä»¬é‡‡ç”¨æœ€ç®€å•çš„æ–¹æ¡ˆï¼š**JSON æ–‡ä»¶å­˜å‚¨ + çº¯ JavaScript å‘é‡æœç´¢**ï¼Œè¿™ç§æ–¹æ¡ˆç®€å•ã€å¯é ã€æ— éœ€å¤æ‚ä¾èµ–ã€‚

## æ ¸å¿ƒä¾èµ–

ä¸ºäº†å®ç°æ­¤åŠŸèƒ½ï¼Œæˆ‘ä»¬åªéœ€è¦ä»¥ä¸‹æ ¸å¿ƒåº“ï¼š

-   `@xenova/transformers`: ç”¨äºåœ¨æœ¬åœ°ç”Ÿæˆæ–‡æœ¬ embedding çš„åº“ï¼ˆå¯é€‰ï¼Œä¹Ÿå¯ä½¿ç”¨ Ollama æˆ–äº‘ç«¯ APIï¼‰ã€‚

## æ ¸å¿ƒå®ç°æ­¥éª¤

### 1. æ•°æ®ç»“æ„è®¾è®¡

å‘é‡æ•°æ®ä»¥ JSON æ ¼å¼å­˜å‚¨ï¼Œæ¯ä¸ªæ¡ç›®åŒ…å« block ä¿¡æ¯å’Œå¯¹åº”çš„å‘é‡ï¼š

```typescript
interface VectorData {
  blockUUID: string;
  pageName: string;
  blockContent: string;
  vector: number[];  // å‘é‡æ•°ç»„
  lastUpdated: number; // æ—¶é—´æˆ³
}

// æ•´ä¸ªå‘é‡æ•°æ®åº“å°±æ˜¯ä¸€ä¸ªæ•°ç»„
type VectorDatabase = VectorData[];
```

### 2. å­˜å‚¨å’ŒåŠ è½½å‡½æ•°

ä½¿ç”¨ Logseq çš„æŒä¹…åŒ–å­˜å‚¨ API æ¥ä¿å­˜å’Œè¯»å–å‘é‡æ•°æ®ï¼š

```typescript
const VECTOR_STORAGE_KEY = 'ai-search-vector-data';

// ä¿å­˜å‘é‡æ•°æ®
async function saveVectorData(vectorData: VectorDatabase): Promise<void> {
  try {
    await logseq.Assets.makeSandboxStorage();
    const jsonString = JSON.stringify(vectorData);
    await logseq.Assets.writeFile(VECTOR_STORAGE_KEY + '.json', jsonString);
    console.log(`ä¿å­˜äº† ${vectorData.length} æ¡å‘é‡æ•°æ®`);
  } catch (error) {
    console.error("ä¿å­˜å‘é‡æ•°æ®å¤±è´¥:", error);
    throw error;
  }
}

// åŠ è½½å‘é‡æ•°æ®
async function loadVectorData(): Promise<VectorDatabase> {
  try {
    await logseq.Assets.makeSandboxStorage();
    const exists = await logseq.Assets.existsFile(VECTOR_STORAGE_KEY + '.json');
    if (!exists) {
      console.log("å‘é‡æ•°æ®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›ç©ºæ•°ç»„");
      return [];
    }
    
    const jsonString = await logseq.Assets.readFile(VECTOR_STORAGE_KEY + '.json');
    const vectorData: VectorDatabase = JSON.parse(jsonString);
    console.log(`åŠ è½½äº† ${vectorData.length} æ¡å‘é‡æ•°æ®`);
    return vectorData;
  } catch (error) {
    console.error("åŠ è½½å‘é‡æ•°æ®å¤±è´¥:", error);
    return [];
  }
}
```

### 3. ç”Ÿæˆ Embedding

æ”¯æŒå¤šç§ embedding ç”Ÿæˆæ–¹å¼ï¼š

```typescript
// Ollama API è°ƒç”¨
async function generateOllamaEmbedding(text: string): Promise<number[]> {
  const ollamaHost = String(logseq.settings?.ollamaHost || "http://localhost:11434");
  const modelName = String(logseq.settings?.ollamaEmbeddingModel || "nomic-embed-text");
  
  try {
    const response = await fetch(`${ollamaHost}/api/embeddings`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: modelName,
        prompt: text
      })
    });

    if (!response.ok) {
      throw new Error(`Ollama API error: ${response.status}`);
    }

    const data = await response.json();
    return data.embedding;
  } catch (error) {
    console.error("Ollama embedding failed:", error);
    throw error;
  }
}

// äº‘ç«¯APIè°ƒç”¨
async function generateCloudEmbedding(text: string): Promise<number[]> {
  const apiUrl = String(logseq.settings?.cloudEmbeddingApiUrl || "https://api.siliconflow.cn/v1/embeddings");
  const apiKey = String(logseq.settings?.cloudEmbeddingApiKey || "");
  const modelName = String(logseq.settings?.cloudEmbeddingModel || "BAAI/bge-m3");

  if (!apiKey) {
    throw new Error("äº‘ç«¯APIå¯†é’¥æœªè®¾ç½®");
  }

  try {
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: modelName,
        input: text
      })
    });

    if (!response.ok) {
      throw new Error(`Cloud API error: ${response.status}`);
    }

    const data = await response.json();
    return data.data[0].embedding;
  } catch (error) {
    console.error("Cloud embedding failed:", error);
    throw error;
  }
}

// ç»Ÿä¸€çš„embeddingç”Ÿæˆå‡½æ•°
async function generateEmbedding(text: string): Promise<number[]> {
  const serviceType = getEmbeddingServiceType();
  
  if (serviceType === 'ollama') {
    return await generateOllamaEmbedding(text);
  } else {
    return await generateCloudEmbedding(text);
  }
}

function getEmbeddingServiceType(): 'ollama' | 'cloud' {
  const selected = String(logseq.settings?.embeddingModel || "Ollamaæœ¬åœ°æ¨¡å‹ / Ollama Local Model");
  return selected.includes("Ollama") ? 'ollama' : 'cloud';
}
```

### 4. æ„å»ºå‘é‡ç´¢å¼•

éå†æ‰€æœ‰ blocksï¼Œç”Ÿæˆå‘é‡å¹¶ä¿å­˜ï¼š

```typescript
async function indexAllPages(): Promise<void> {
  try {
    logseq.UI.showMsg("å¼€å§‹å»ºç«‹å‘é‡ç´¢å¼•...", "success");
    console.log("Starting to build vector index...");

    const allBlocks = await getAllBlocksWithPage();
    if (!allBlocks || allBlocks.length === 0) {
      logseq.UI.showMsg("æ²¡æœ‰éœ€è¦ç´¢å¼•çš„å†…å®¹ã€‚", "warning");
      return;
    }

    // æµ‹è¯•æ¨¡å¼ï¼šåªç´¢å¼•éƒ¨åˆ†blocks
    const testLimit = Number(logseq.settings?.testModeBlockLimit) || 0;
    const blocksToIndex = testLimit > 0 ? allBlocks.slice(0, testLimit) : allBlocks;
    
    console.log(`Found ${allBlocks.length} blocks total, indexing ${blocksToIndex.length} blocks.`);
    if (testLimit > 0) {
      logseq.UI.showMsg(`ğŸ§ª æµ‹è¯•æ¨¡å¼ï¼šåªç´¢å¼•å‰ ${blocksToIndex.length} ä¸ªblocks`, "info", { timeout: 3000 });
    }
    
    const vectorData: VectorDatabase = [];
    let indexedCount = 0;
    const currentTime = Date.now();
    
    for (const block of blocksToIndex) {
      try {
        const vector = await generateEmbedding(block.content);
        vectorData.push({
          blockUUID: block.uuid,
          pageName: block.pageName,
          blockContent: block.content,
          vector: vector,
          lastUpdated: currentTime
        });
        
        indexedCount++;
        
        // æ˜¾ç¤ºè¿›åº¦
        const progress = Math.round((indexedCount / blocksToIndex.length) * 100);
        if (indexedCount % 10 === 0 || indexedCount === blocksToIndex.length) {
          logseq.UI.showMsg(`ç´¢å¼•å»ºç«‹ä¸­... ${progress}% (${indexedCount}/${blocksToIndex.length})`);
          console.log(`Indexed ${indexedCount}/${blocksToIndex.length} blocks (${progress}%)`);
        }
      } catch (error) {
        console.error(`Failed to generate embedding for block ${block.uuid}:`, error);
        // ç»§ç»­å¤„ç†å…¶ä»–blocks
      }
    }

    // ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨
    await saveVectorData(vectorData);
    
    logseq.UI.showMsg(`âœ… ç´¢å¼•å»ºç«‹å®Œæˆï¼å…± ${indexedCount} æ¡å†…å®¹ã€‚`, "success", { timeout: 5000 });

  } catch (error) {
    console.error("Failed to index all pages:", error);
    logseq.UI.showMsg("ç´¢å¼•å»ºç«‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ã€‚", "error");
  }
}
```

### 5. å‘é‡æœç´¢å‡½æ•°

ä½¿ç”¨ä½™å¼¦ç›¸ä¼¼åº¦è¿›è¡Œå‘é‡æœç´¢ï¼š

```typescript
// è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
function cosineSimilarity(vecA: number[], vecB: number[]): number {
  if (vecA.length !== vecB.length) {
    throw new Error('å‘é‡ç»´åº¦ä¸åŒ¹é…');
  }
  
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  
  for (let i = 0; i < vecA.length; i++) {
    dotProduct += vecA[i] * vecB[i];
    normA += vecA[i] * vecA[i];
    normB += vecB[i] * vecB[i];
  }
  
  if (normA === 0 || normB === 0) {
    return 0;
  }
  
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}

// å‘é‡æœç´¢
async function searchBlocks(queryText: string, limit: number = 10) {
  try {
    console.log(`Searching for: "${queryText}"`);
    
    // ç”ŸæˆæŸ¥è¯¢å‘é‡
    const queryVector = await generateEmbedding(queryText);
    
    // åŠ è½½æ‰€æœ‰å‘é‡æ•°æ®
    const vectorData = await loadVectorData();
    
    if (vectorData.length === 0) {
      logseq.UI.showMsg("å‘é‡æ•°æ®ä¸ºç©ºï¼Œè¯·å…ˆå»ºç«‹ç´¢å¼•", "warning");
      return [];
    }
    
    // è®¡ç®—ç›¸ä¼¼åº¦å¹¶æ’åº
    const results = vectorData.map(item => ({
      blockUUID: item.blockUUID,
      pageName: item.pageName,
      blockContent: item.blockContent,
      score: cosineSimilarity(queryVector, item.vector)
    }))
    .sort((a, b) => b.score - a.score)  // æŒ‰ç›¸ä¼¼åº¦é™åºæ’åˆ—
    .slice(0, limit);  // å–å‰ limit ä¸ªç»“æœ

    console.log("Search results:", results);
    return results;

  } catch (error) {
    console.error("Search failed:", error);
    logseq.UI.showMsg("æœç´¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ã€‚", "error");
    return [];
  }
}
```

### 6. è¾…åŠ©å‡½æ•°

```typescript
interface BlockWithPage {
  uuid: string;
  content: string;
  pageName: string;
}

// è·å–æ‰€æœ‰é¡µé¢ä¸­çš„ Block
async function getAllBlocksWithPage(): Promise<BlockWithPage[]> {
  try {
    const allPages = await logseq.Editor.getAllPages();
    if (!allPages) {
      return [];
    }

    let allBlocks: BlockWithPage[] = [];

    for (const page of allPages) {
      const pageBlocks = await logseq.Editor.getPageBlocksTree(page.name);
      if (pageBlocks) {
        const flattenedBlocks = flattenBlocks(pageBlocks).map(block => ({
          uuid: block.uuid,
          content: block.content,
          pageName: page.name
        }));
        allBlocks = allBlocks.concat(flattenedBlocks);
      }
    }
    
    // è¿‡æ»¤æ‰å†…å®¹ä¸ºç©ºçš„ block
    return allBlocks.filter(block => block.content && block.content.trim() !== '');

  } catch (error) {
    console.error("Error getting all blocks:", error);
    return [];
  }
}

function flattenBlocks(blocks: BlockEntity[]): BlockEntity[] {
  let flattened: BlockEntity[] = [];
  for (const block of blocks) {
    flattened.push(block);
    if (block.children && block.children.length > 0) {
      flattened = flattened.concat(flattenBlocks(block.children as BlockEntity[]));
    }
  }
  return flattened;
}

// è·å–ç»Ÿè®¡ä¿¡æ¯
async function getVectorStoreStats() {
  try {
    const vectorData = await loadVectorData();
    const count = vectorData.length;
    const dim = vectorData.length > 0 ? vectorData[0].vector.length : 0;
    return { count, dim };
  } catch (error) {
    console.error("Failed to get vector store stats:", error);
    return { count: 0, dim: 0 };
  }
}
```

## ä¼˜åŠ¿

è¿™ä¸ªç®€å•æ–¹æ¡ˆå…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

1. **ç®€å•å¯é **ï¼šæ— éœ€å¤æ‚çš„æ•°æ®åº“ä¾èµ–ï¼Œåªä½¿ç”¨ JSON æ–‡ä»¶å­˜å‚¨
2. **å®Œå…¨æœ¬åœ°**ï¼šæ•°æ®å­˜å‚¨åœ¨ Logseq æ’ä»¶çš„æ²™ç®±å­˜å‚¨ä¸­ï¼Œå®Œå…¨ç§æœ‰
3. **æ˜“äºè°ƒè¯•**ï¼šå¯ä»¥ç›´æ¥æŸ¥çœ‹å’Œç¼–è¾‘ JSON æ–‡ä»¶
4. **å¿«é€Ÿå¯åŠ¨**ï¼šæ— éœ€åˆå§‹åŒ–å¤æ‚çš„æ•°æ®åº“
5. **å†…å­˜å‹å¥½**ï¼šåªåœ¨éœ€è¦æ—¶åŠ è½½æ•°æ®åˆ°å†…å­˜
6. **è·¨å¹³å°å…¼å®¹**ï¼šåœ¨ä»»ä½•æ”¯æŒ Logseq çš„å¹³å°ä¸Šéƒ½èƒ½å·¥ä½œ

## æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½è€ƒè™‘**ï¼šå¯¹äºå¤§é‡æ•°æ®ï¼ˆ>10ä¸‡ä¸ªblocksï¼‰ï¼Œæœç´¢å¯èƒ½ä¼šæ¯”è¾ƒæ…¢
2. **å†…å­˜ä½¿ç”¨**ï¼šæ‰€æœ‰å‘é‡æ•°æ®ä¼šåŠ è½½åˆ°å†…å­˜ä¸­è¿›è¡Œæœç´¢
3. **å¤‡ä»½**ï¼šJSON æ–‡ä»¶å¯ä»¥ç›´æ¥å¤åˆ¶å¤‡ä»½ï¼Œä¾¿äºæ•°æ®è¿ç§»
4. **å¢é‡æ›´æ–°**ï¼šç›®å‰æ˜¯å…¨é‡é‡å»ºç´¢å¼•ï¼Œåç»­å¯ä»¥ä¼˜åŒ–ä¸ºå¢é‡æ›´æ–°

## å‚è€ƒèµ„æº

- [Logseq Plugin API](https://plugins-doc.logseq.com/) - äº†è§£ Logseq æ’ä»¶å¼€å‘
- [Logseq Assets API](https://plugins-doc.logseq.com/#/hi_logseq.assets) - äº†è§£æ–‡ä»¶å­˜å‚¨ API

- [VSS æ‰©å±•æ–‡æ¡£](https://github.com/duckdb/duckdb_vss) - äº†è§£å‘é‡æœç´¢æ‰©å±•çš„ä½¿ç”¨æ–¹æ³•
- [DuckDB SQL å‚è€ƒ](https://duckdb.org/docs/sql/introduction) - äº†è§£DuckDBçš„SQLè¯­æ³•
- [DuckDB æ•°ç»„ç±»å‹](https://duckdb.org/docs/sql/data_types/array) - äº†è§£å¦‚ä½•ä½¿ç”¨æ•°ç»„å­˜å‚¨å‘é‡
- [HNSW ç´¢å¼•](https://github.com/duckdb/duckdb_vss#hnsw-index) - äº†è§£HNSWç´¢å¼•çš„åˆ›å»ºå’Œä½¿ç”¨
