---
description: 本指南用于在 Logseq AI 搜索插件中实现简单的本地向量存储。我们的目标是实现基于本地 embedding 的、以 logseq笔记软件中的最小单位 `block` 为单位的向量搜索功能，支持动态增量索引以保持数据同步。
alwaysApply: false
---
# 简单向量存储使用指南

本指南用于在 Logseq AI 搜索插件中实现简单的本地向量存储。我们的目标是实现基于本地 embedding 的、以 logseq笔记软件中的最小单位 `block` 为单位的向量搜索功能，支持动态增量索引以保持数据同步。

我们采用灵活的存储方案：**localStorage分片存储 + 压缩分块技术 + 智能增量索引**，确保稳定性、大容量支持和数据实时性。

## 核心架构原则

### 1. 存储策略选择

**当前方案：增强型localStorage**
- 分块压缩存储技术，突破5-10MB限制
- 智能容量检测和QuotaExceededError处理
- 元数据管理，支持增量读写
- 自动清理和恢复机制
- 内存缓存机制，提升搜索性能

**已弃用方案：**
- IndexedDB：在 Logseq 插件环境中确认不兼容【已测试确认】
- Assets API：虽然理论上更好，但在实际使用中存在兼容性问题

### 2. 数据结构设计

**核心数据结构：**
```typescript
interface VectorData {
  blockUUID: string;      // Logseq block的唯一标识
  pageName: string;       // 所属页面名称
  blockContent: string;   // 预处理后的block内容
  vector: number[];       // embedding向量
  lastUpdated: number;    // 最后更新时间戳
}
```

**存储优化结构：**
```typescript
interface CompactVectorData {
  u: string;      // blockUUID (缩短字段名)
  p: string;      // pageName
  c: string;      // blockContent
  v: number[];    // vector (压缩精度到4位小数)
  t: number;      // lastUpdated timestamp
}
```

### 3. 动态增量索引机制

**核心原理：**
- 在用户触发搜索时，自动检测笔记内容变化
- 只对新增或修改的blocks进行索引，避免全量重建
- 保持向量数据与用户笔记内容的实时同步
- 用户无感知的后台自动更新

**实现策略：**
1. **变化检测**：比较当前所有blocks与已索引的blockUUIDs
2. **增量索引**：只处理新增的blocks，跳过已存在的
3. **智能触发**：在搜索时自动执行，用户无感知
4. **性能优化**：使用内存缓存，避免重复加载数据

**最佳实践：**
- 首次使用需要手动建立完整索引
- 后续搜索会自动维护索引同步
- 大量新增内容时可手动触发"继续索引"
- 定期检查索引完整性

### 4. 错误处理和兼容性管理

**localStorage容量管理：**
- QuotaExceededError智能捕获
- 自动分块存储（每块1000条记录）
- 元数据管理，追踪数据完整性
- 清晰的错误提示和解决建议

### 5. 性能优化策略

**增量索引优化：**
- 智能变化检测：只处理新增blocks，避免重复计算
- 内存缓存机制：搜索时优先使用缓存数据
- 批处理：使用Promise.all()并行处理embedding生成
- 进度显示：每200条显示一次进度

**存储优化：**
- 分块压缩存储：突破localStorage容量限制
- 向量精度压缩：保留4位小数，减少存储空间
- 元数据管理：追踪数据完整性和版本信息
- 自动清理：定期清理无效数据

### 5. 用户控制和配置

**存储模式选择：**
- 插件设置中提供存储模式选择
- 支持运行时切换（重建索引时生效）
- 默认优先使用Assets文件存储

**调试工具：**
- Assets API测试命令：验证文件操作是否可用
- 数据状态查看：显示存储位置、大小、时间戳
- 清理命令：支持清除所有向量数据（包括分块）

### 6. 实际部署经验

**Assets API使用技巧：**
1. 动态方法检测比硬编码更可靠
2. 错误处理必须覆盖API调用的每个环节
3. 自动降级确保插件在各种环境下都能工作
4. 详细日志帮助定位兼容性问题

**localStorage优化技巧：**
1. 分块存储可以突破单个键值对的大小限制
2. 元数据管理确保数据完整性
3. 压缩存储在容量紧张时非常有效
4. 定期清理避免累积无效数据

**性能调优要点：**
1. 批处理embedding生成显著提升速度
2. 进度显示改善用户体验
3. 增量保存避免数据丢失
4. 内存管理防止浏览器卡顿

## 故障排除指南

### 1. Assets API问题

**API方法不存在：**
- 使用动态检测，尝试多种可能的方法名
- 查看控制台日志确认具体的错误信息
- 自动降级到localStorage确保功能可用

**文件写入失败：**
- 检查assets目录权限
- 确认文件名不包含特殊字符
- 降级使用localStorage作为备选方案

### 2. localStorage容量问题

**QuotaExceededError：**
- 启用分块压缩存储
- 清理浏览器存储数据
- 考虑减少索引的blocks数量

### 3. 数据一致性问题

**分块数据损坏：**
- 使用Vector Debug命令查看数据状态
- 必要时清除所有数据重新建立索引
- 检查元数据文件完整性

## 最佳实践总结

**关键教训：**
1. 多重备选方案比单一方案更可靠
2. 自动降级机制确保插件稳定性
3. 用户体验比技术复杂度更重要
4. 详细的错误处理和日志不可忽视
5. 灵活的配置选项满足不同用户需求

**成功因素：**
1. 优先考虑兼容性和稳定性
2. 提供清晰的错误提示和解决方案
3. 实现渐进式功能，支持部分失败场景
4. 重视性能优化和用户体验
5. 保持代码简洁，易于维护和调试

## 参考资源
- [Logseq Plugin API](https://plugins-doc.logseq.com/) - 了解 Logseq 插件开发
- [Logseq Plugin API](https://logseq.github.io/plugins/modules.html) - 了解 Logseq 插件开发
