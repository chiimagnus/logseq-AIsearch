// å°è£…äº† AI æ¨¡å‹åŠ è½½ã€æ•°æ®åº“åˆå§‹åŒ–ã€å†…å®¹ç´¢å¼•å’Œå‘é‡æœç´¢çš„å…¨éƒ¨æ ¸å¿ƒé€»è¾‘ã€‚

import * as lancedb from '@lancedb/lancedb';
import { BlockEntity } from '@logseq/libs/dist/LSPlugin';

// 1. å®šä¹‰æ ¸å¿ƒå˜é‡
let db: lancedb.Connection;
let table: lancedb.Table;
let isInitialized = false;

// åŠ¨æ€è·å–æ‰¹å¤„ç†å¤§å°
function getBatchSize(): number {
  return Number(logseq.settings?.vectorBatchSize) || 100;
}

// è·å–embeddingæœåŠ¡ç±»å‹
function getEmbeddingServiceType(): 'ollama' | 'cloud' {
  const selected = String(logseq.settings?.embeddingModel || "Ollamaæœ¬åœ°æ¨¡å‹ / Ollama Local Model");
  return selected.includes("Ollama") ? 'ollama' : 'cloud';
}

// è·å–å‘é‡ç»´åº¦ï¼ˆæ ¹æ®ä¸åŒæ¨¡å‹ï¼‰
function getVectorDimension(): number {
  const serviceType = getEmbeddingServiceType();
  if (serviceType === 'ollama') {
    // nomic-embed-text çš„ç»´åº¦æ˜¯ 768
    return 768;
  } else {
    // BAAI/bge-m3 çš„ç»´åº¦æ˜¯ 1024  
    return 1024;
  }
}

// Ollama APIè°ƒç”¨
async function generateOllamaEmbedding(text: string): Promise<number[]> {
  const ollamaHost = String(logseq.settings?.ollamaHost || "http://localhost:11434");
  const modelName = String(logseq.settings?.ollamaEmbeddingModel || "nomic-embed-text");
  
  try {
    const response = await fetch(`${ollamaHost}/api/embeddings`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: modelName,
        prompt: text
      })
    });

    if (!response.ok) {
      throw new Error(`Ollama API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return data.embedding;
  } catch (error) {
    console.error("Ollama embedding failed:", error);
    throw error;
  }
}

// äº‘ç«¯APIè°ƒç”¨
async function generateCloudEmbedding(text: string): Promise<number[]> {
  const apiUrl = String(logseq.settings?.cloudEmbeddingApiUrl || "https://api.siliconflow.cn/v1/embeddings");
  const apiKey = String(logseq.settings?.cloudEmbeddingApiKey || "");
  const modelName = String(logseq.settings?.cloudEmbeddingModel || "BAAI/bge-m3");

  if (!apiKey) {
    throw new Error("äº‘ç«¯APIå¯†é’¥æœªè®¾ç½® / Cloud API key not set");
  }

  try {
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: modelName,
        input: text
      })
    });

    if (!response.ok) {
      throw new Error(`Cloud API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return data.data[0].embedding;
  } catch (error) {
    console.error("Cloud embedding failed:", error);
    throw error;
  }
}

// ç»Ÿä¸€çš„embeddingç”Ÿæˆå‡½æ•°
async function generateEmbedding(text: string): Promise<number[]> {
  const serviceType = getEmbeddingServiceType();
  
  if (serviceType === 'ollama') {
    return await generateOllamaEmbedding(text);
  } else {
    return await generateCloudEmbedding(text);
  }
}

// 2. åˆå§‹åŒ–å‡½æ•°
export async function initializeVectorStore() {
  if (isInitialized) {
    console.log("Vector store already initialized.");
    return;
  }
  console.log("Vector store initializing...");
  
  try {
    // åˆå§‹åŒ– LanceDB
    if (!db) {
        const dbPath = `${logseq.settings!.pluginDir}/.lancedb`;
        db = await lancedb.connect(dbPath);
        console.log(`LanceDB connected at: ${dbPath}`);
        logseq.UI.showMsg(`ğŸ“ å‘é‡æ•°æ®åº“è·¯å¾„: ${dbPath}`, "info", { timeout: 5000 });
    }

    // è·å–æˆ–åˆ›å»ºæ•°æ®è¡¨
    const tableNames = await db.tableNames();
    const vectorDim = getVectorDimension();
    
    if (tableNames.includes('logseq_blocks')) {
        table = await db.openTable('logseq_blocks');
        console.log("Opened existing table 'logseq_blocks'.");
    } else {
        console.log("Creating new table 'logseq_blocks'...");
        const dummyData = [{
            vector: Array(vectorDim).fill(0),
            blockUUID: "dummy",
            pageName: "dummy",
            blockContent: "dummy"
        }];
        table = await db.createTable("logseq_blocks", dummyData, { mode: "overwrite" });
        console.log("Created new table 'logseq_blocks'.");
    }

    // æµ‹è¯•embeddingæœåŠ¡è¿æ¥
    const serviceType = getEmbeddingServiceType();
    logseq.UI.showMsg(`ğŸ”§ æ­£åœ¨æµ‹è¯•${serviceType === 'ollama' ? 'Ollama' : 'äº‘ç«¯'}embeddingæœåŠ¡...`, "info");
    
    try {
      await generateEmbedding("æµ‹è¯•è¿æ¥");
      logseq.UI.showMsg(`âœ… ${serviceType === 'ollama' ? 'Ollama' : 'äº‘ç«¯'}embeddingæœåŠ¡è¿æ¥æˆåŠŸ`, "success", { timeout: 3000 });
    } catch (error) {
      console.error("Embedding service test failed:", error);
      logseq.UI.showMsg(`âŒ embeddingæœåŠ¡è¿æ¥å¤±è´¥: ${error}`, "error", { timeout: 8000 });
      return;
    }

    isInitialized = true;
    console.log("Vector store initialized successfully.");

  } catch (error) {
      console.error("Vector store initialization failed:", error);
      logseq.UI.showMsg("å‘é‡æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—", "error");
  }
}

// 3. ç´¢å¼•å…¨éƒ¨é¡µé¢
export async function indexAllPages() {
  if (!isInitialized || !db || !table) {
    logseq.UI.showMsg("å‘é‡æ•°æ®åº“æœªåˆå§‹åŒ–ï¼Œè¯·ç¨åå†è¯•ã€‚", "error");
    return;
  }

  try {
    logseq.UI.showMsg("å¼€å§‹å»ºç«‹å‘é‡ç´¢å¼•...", "success");
    console.log("Starting to build vector index...");

    const allBlocks = await getAllBlocksWithPage();
    if (!allBlocks || allBlocks.length === 0) {
      logseq.UI.showMsg("æ²¡æœ‰éœ€è¦ç´¢å¼•çš„å†…å®¹ã€‚", "warning");
      console.log("No blocks found to index.");
      return;
    }

    // æµ‹è¯•æ¨¡å¼ï¼šåªç´¢å¼•éƒ¨åˆ†blocks
    const testLimit = Number(logseq.settings?.testModeBlockLimit) || 0;
    const blocksToIndex = testLimit > 0 ? allBlocks.slice(0, testLimit) : allBlocks;
    
    console.log(`Found ${allBlocks.length} blocks total, indexing ${blocksToIndex.length} blocks.`);
    if (testLimit > 0) {
      logseq.UI.showMsg(`ğŸ§ª æµ‹è¯•æ¨¡å¼ï¼šåªç´¢å¼•å‰ ${blocksToIndex.length} ä¸ªblocks`, "info", { timeout: 3000 });
    }
    
    // æ¸…ç©ºæ—§è¡¨å¹¶é‡å»º
    await db.dropTable("logseq_blocks");
    const vectorDim = getVectorDimension();
    const dummyData = [{ vector: Array(vectorDim).fill(0), blockUUID: "dummy", pageName: "dummy", blockContent: "dummy" }];
    table = await db.createTable("logseq_blocks", dummyData, { mode: "overwrite" });
    console.log("Old table dropped and new table created for re-indexing.");

    let indexedCount = 0;
    const batchSize = getBatchSize();
    
    for (let i = 0; i < blocksToIndex.length; i += batchSize) {
      const batch = blocksToIndex.slice(i, i + batchSize);
      
      // é€ä¸ªç”Ÿæˆembeddingï¼ˆé¿å…æ‰¹å¤„ç†APIé™åˆ¶ï¼‰
      const data = [];
      for (const block of batch) {
        try {
          const vector = await generateEmbedding(block.content);
          data.push({
            vector,
            blockUUID: block.uuid,
            pageName: block.pageName,
            blockContent: block.content
          });
          indexedCount++;
          
          // æ˜¾ç¤ºè¯¦ç»†è¿›åº¦
          const progress = Math.round((indexedCount / blocksToIndex.length) * 100);
          if (indexedCount % 10 === 0 || indexedCount === blocksToIndex.length) {
            logseq.UI.showMsg(`ç´¢å¼•å»ºç«‹ä¸­... ${progress}% (${indexedCount}/${blocksToIndex.length})`);
            console.log(`Indexed ${indexedCount}/${blocksToIndex.length} blocks (${progress}%)`);
          }
        } catch (error) {
          console.error(`Failed to generate embedding for block ${block.uuid}:`, error);
          // ç»§ç»­å¤„ç†å…¶ä»–blocks
        }
      }

      if (data.length > 0) {
        await table.add(data);
        console.log(`Added batch of ${data.length} blocks to database.`);
      }
    }

    console.log("Start creating IVF_PQ index on vector column.");
    logseq.UI.showMsg(`ç´¢å¼•æ•°æ®æ·»åŠ å®Œæ¯•ï¼Œå¼€å§‹æ„å»ºå¿«é€Ÿæœç´¢ç´¢å¼•...`, "success");
    await table.createIndex("vector");
    console.log("Index created successfully.");

    logseq.UI.showMsg(`âœ… ç´¢å¼•å»ºç«‹å®Œæˆï¼å…± ${indexedCount} æ¡å†…å®¹ã€‚`, "success", { timeout: 5000 });

  } catch (error) {
    console.error("Failed to index all pages:", error);
    logseq.UI.showMsg("ç´¢å¼•å»ºç«‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ã€‚", "error");
  }
}

interface BlockWithPage {
  uuid: string;
  content: string;
  pageName: string;
}

async function getAllBlocksWithPage(): Promise<BlockWithPage[]> {
  try {
    const allPages = await logseq.Editor.getAllPages();
    if (!allPages) return [];

    let allBlocksWithPage: BlockWithPage[] = [];

    for (const page of allPages) {
      if (page.name) {
        const pageBlocks = await logseq.Editor.getPageBlocksTree(page.name);
        const flatBlocks = flattenBlocks(pageBlocks);
        
        const blocksWithPage = flatBlocks
          .filter(block => block.content && block.content.trim() !== '')
          .map(block => ({
            uuid: block.uuid,
            content: block.content,
            pageName: page.name
          }));
        
        allBlocksWithPage.push(...blocksWithPage);
      }
    }
    return allBlocksWithPage;
  } catch (error) {
    console.error("Error getting all blocks:", error);
    return [];
  }
}

function flattenBlocks(blocks: BlockEntity[]): BlockEntity[] {
  let flatBlocks: BlockEntity[] = [];
  for (const block of blocks) {
    flatBlocks.push(block);
    if (block.children && block.children.length > 0) {
      flatBlocks = flatBlocks.concat(flattenBlocks(block.children as BlockEntity[]));
    }
  }
  return flatBlocks;
}

// 4. è·å–åˆå§‹åŒ–çŠ¶æ€
export function getInitializationStatus() {
  return {
    isInitialized,
    hasDatabase: !!db,
    hasTable: !!table,
    embeddingService: getEmbeddingServiceType()
  };
}

// 5. æœç´¢å‡½æ•°
export async function search(queryText: string) {
  if (!isInitialized || !table) {
    const status = getInitializationStatus();
    console.error("Vector search service not properly initialized:", status);
    logseq.UI.showMsg("å‘é‡æœç´¢æœåŠ¡æœªåˆå§‹åŒ–ï¼Œè¯·æ£€æŸ¥è®¾ç½®æˆ–é‡å»ºç´¢å¼• | Vector search service not initialized", "error");
    return [];
  }

  try {
    console.log(`Searching for: "${queryText}"`);

    // 1. ä¸ºæŸ¥è¯¢æ–‡æœ¬ç”Ÿæˆ embedding
    const queryVector = await generateEmbedding(queryText);

    // 2. æ‰§è¡Œæœç´¢
    const searchResults = await table
      .search(queryVector)
      .limit(Number(logseq.settings?.maxResults || 50))
      .toArray();
    
    console.log(`Found ${searchResults.length} results.`);
    return searchResults;

  } catch (error) {
    console.error("Search failed:", error);
    logseq.UI.showMsg("æœç´¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ã€‚", "error");
    return [];
  }
}

// æ·»åŠ è°ƒè¯•å’Œç»Ÿè®¡åŠŸèƒ½
export async function getVectorStoreStats() {
  if (!isInitialized || !table) {
    return {
      error: "Vector store not initialized"
    };
  }

  try {
    const countResult = await table.countRows();
    const vectorDim = getVectorDimension();
    const sampleData = await table.search([0.1, 0.1, 0.1, ...Array(vectorDim - 3).fill(0)]).limit(5).toArray();
    
    const serviceType = getEmbeddingServiceType();
    const serviceConfig = serviceType === 'ollama' 
      ? {
          host: String(logseq.settings?.ollamaHost || "http://localhost:11434"),
          model: String(logseq.settings?.ollamaEmbeddingModel || "nomic-embed-text")
        }
      : {
          apiUrl: String(logseq.settings?.cloudEmbeddingApiUrl || ""),
          model: String(logseq.settings?.cloudEmbeddingModel || "BAAI/bge-m3")
        };
    
    return {
      totalBlocks: countResult,
      modelInfo: {
        serviceType,
        dimension: vectorDim,
        config: serviceConfig
      },
      indexInfo: {
        batchSize: getBatchSize(),
        hasSearchIndex: true,
        testModeLimit: Number(logseq.settings?.testModeBlockLimit) || 0
      },
      databasePath: `${logseq.settings!.pluginDir}/.lancedb`,
      sampleBlocks: sampleData.map(item => ({
        blockUUID: item.blockUUID,
        pageName: item.pageName,
        contentPreview: item.blockContent.substring(0, 100) + "...",
        vectorPreview: item.vector.slice(0, 5) // åªæ˜¾ç¤ºå‰5ä¸ªç»´åº¦
      }))
    };
  } catch (error) {
    return {
      error: `Failed to get stats: ${error}`
    };
  }
}

// æ·»åŠ ç›¸ä¼¼åº¦æµ‹è¯•åŠŸèƒ½
export async function testSimilarity(query1: string, query2: string) {
  if (!isInitialized) {
    return { error: "Vector store not initialized" };
  }

  try {
    const vector1 = await generateEmbedding(query1);
    const vector2 = await generateEmbedding(query2);
    
    // è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
    const dotProduct = vector1.reduce((sum, a, i) => sum + a * vector2[i], 0);
    const magnitude1 = Math.sqrt(vector1.reduce((sum, a) => sum + a * a, 0));
    const magnitude2 = Math.sqrt(vector2.reduce((sum, a) => sum + a * a, 0));
    const similarity = dotProduct / (magnitude1 * magnitude2);
    
    return {
      query1,
      query2,
      similarity,
      interpretation: similarity > 0.8 ? "å¾ˆç›¸ä¼¼" : similarity > 0.6 ? "è¾ƒç›¸ä¼¼" : similarity > 0.4 ? "æœ‰äº›ç›¸ä¼¼" : "ä¸å¤ªç›¸ä¼¼"
    };
  } catch (error) {
    return { error: `Similarity test failed: ${error}` };
  }
} 